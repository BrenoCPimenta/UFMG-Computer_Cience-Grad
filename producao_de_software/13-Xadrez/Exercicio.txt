Descrição

Nesse trabalho, iremos explorar a lógica de movimentação de três dos seis diferente tipos de peças do xadrez em sua variação mais clássica. São as peças Bispo (Bishop), Cavalo (Knight) e Torre (Rook). Considere que cada uma das peças executa os seguintes movimentos:

Bispo: move-se pela diagonal.
Cavalo: movimenta-se sempre em "L", ou seja, duas casas para frente, para o lado ou para trás e uma para a esquerda ou direita. 
Torre: movimenta-se em direção reta pelas colunas ou fileiras.
Regras

Para facilitar a implementação desse exercício, algumas regras foram estabelecidas:

Tabuleiro

1) Considera-se única e exclusivamente um tabuleiro no formato 8x8, com coordenadas dada conforme um tabuleiro original. Isso significa que todas as coordenadas obedecem o padrão: 

Coordenada: letraNúmero. Exemplos: a1, b2, c3... 

Além disso, nenhuma coordenada é dada por uma letra não minúscula ou que não esteja no conjunto [a,b,c,d,e,f,g,h], e nenhum número é menor do que 1 ou maior do que 8. Sendo assim, as únicas coordenadas possíveis são aquelas existentes em um tabuleiro padrão.

2) As coordenadas SEMPRE  devem obedecer o padrão letraNúmero, seja para a exibição, seja para a entrada.

3) Para referência: https://www.chessset.com/assets/images/floppyblack.jpg

Peças

1) Cada uma das peças possuí um símbolo que a representa:
Bispo: B, Cavalo: N, Torre: R. Esses símbolos são case sensitive.

2) Cada peça possuí uma classe que a identifica. Todas essas classes herdam de uma classe padrão chamada "Piece". Todas as classes utilizam o construtor de Piece, e o mesmo deverá ser implementado.

3) Todas as peças DEVEM IMPLEMENTAR um método próprio chamado setMovements. Nesse método você deverá escrever a lógica para movimentação de uma peça. Perceba que esse método no arquivo .hpp cedido possui a sua declaração na classe Pieces.

4) Peças devem se movimentar SE E SOMENTE SE o movimento for permitido. Caso o movimento não seja permitido, a peça permanece em sua posição corrente.

5) Um movimento para a posição corrente é considerado ILEGAL. 

Entrada e Saída

1) Nesse exercício não está disponível para modificação o arquivo main.cpp. Assuma que o mesmo está corretamente implementado. Caso você julgue necessário, veja a implementação do mesmo para solucionar possíveis dúvidas aqui.

2) Existem duas variações para a entrada desse trabalho. A entrada pode conter dois ou três argumentos. Entradas com três argumentos caracterizam a criação de uma peça seguida de uma movimentação, e entradas com dois argumentos caracterizam apenas a movimentação de uma peça. Exemplos:
2.1) N a3 c4 - Criação de um Cavalo, na casa a3 que verifica a possibilidade de se mover para a casa c4. Se for possível, a peça vai para c4. Se não, permanece onde está.
2.2) N c5 - Verifica se o cavalo pode se mover da posição corrente para a posição c5. Se for possível, a peça vai para c5. Se não, permanece onde está.

Importante: A segunda variação NUNCA será usada caso a peça ainda não exista. 

3) O construtor da classe Piece recebe como argumento três parâmetros do tipo string e necessariamente na seguinte ordem:  (símbolo, posiçãoAtual, posiçãoCandidata). 

4) O programa é interrompido caso o símbolo passado seja diferente dos símbolos que identificam as peças.

5) Dois métodos são responsáveis pela impressão das saídas. São eles: printPossibleMoves() e checkMovement(). O primeiro deve imprimir o nome da peça, a sua posição corrente, quantos e quais os possíveis movimentos que ela pode executar a partir da sua posição atual em ordem alfabética da posição final. O segundo deve imprimir se o movimento proposto foi executado ou não. Veja os exemplos para correta formatação da saída.

Tarefa

1) Utilize os conceitos de Herança e Classe abstrata (Interfaces) para implementar as funções das classes Rook, Bishop e Knight. O arquivo .hpp de Piece é dado apenas com a declaração do construtor na classe Piece, mas todas as classes utilizam um construtor, vide a função main.  

2) Utilize os conceitos de Polimorfismo para corretamente definir onde cada um dos métodos deve ser declarado para implementação. Esse item será avaliado na implementação final.

4) Você está autorizado a criar métodos para auxiliar a implementação. 
DICA: Comumente são definidos métodos para checar a condição de existência dos limites do tabuleiro, e para converter as coordenadas dadas. 

5) Uma excelente estrutura para esse trabalho é a estrutura Pair. Mais sobre ela: http://www.cplusplus.com/reference/utility/pair/